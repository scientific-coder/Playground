<!DOCTYPE html>
<html class='v2' dir='ltr'>
<head>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<title>Programming as Composing</title>

</head>

<link href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" rel="stylesheet" type="text/css"></link>
<style>
  body { background-color: #eeeeee; }
  pre, code { font-size: 16px; background-color: white; }
</style>


<pre style="display: none;"><code class="klipse">

(ns my.reagent-examples
  (:require
    [clojure.string :as string]
    [reagent.core :as reagent]
[reagent.ratom]))

(enable-console-print!)
(defn svg-polyline[ps]
(let[[[x0 y0] & ps] ps
init-point (str "M " x0 ", " y0 " ")
seg (fn[[x y]] (str "L " x ", " y " "))]
(reduce #(str %1 (seg %2)) init-point ps)))
(defn draw-polylines[[w h] pss]
          [:svg {:width w :height h}
          [:path {:stroke "black" :stroke-width 1 :fill "none" :d  (reduce str (map svg-polyline pss))}] ])
(defn add [[x0 y0][x1 y1]]
[(+ x0 x1)(+ y0 y1)])
(def make-polylines-transform (comp (partial partial mapv) (partial partial mapv) ))
(defn sin[x]
  (.sin js/Math x))
(defn cos[x]
          (.cos js/Math x))

(def PI
  (.-PI js/Math))
    (def sqrt #(.sqrt js/Math %))

    (defn rotate [a [x y]]
    (let [c (cos a)
          s (sin a)]
    [(- (* c x) (* s y)) (+ (* s x) (* c y))]))
(defn scale [k p]
(mapv (partial * k) p))
(def minus (partial scale -1.))
(def -INF (.-NEGATIVE_INFINITY js/Number))
(def INF (.-POSITIVE_INFINITY js/Number))

    (defn bounding-box[pss]
    (->> pss (reduce into [])(reduce (fn[[[x-min y-min][x-max y-max]][x y]] [[(min x-min x) (min y-min y)][(max x-max x)(max y-max y)]]) [[INF INF][-INF -INF]])))
      (defn make-fitting-transform[[w h] pss]
      (let[[[x-min y-min][x-max y-max]](bounding-box pss)
      s (min (/ w (- x-max x-min)) (/ h (- y-max y-min)))
      center (scale 0.5  (add [x-min y-min] [x-max y-max]))]
      (comp (partial add [(/ w 2) (/ h 2)]) (partial scale s) (partial add (minus center)))))
      (defn draw-fitted-polylines[wh pss]
      (draw-polylines wh ((make-polylines-transform (make-fitting-transform wh pss)) pss)))
(defn make-rotate-around [r a]
  (comp (partial add r)(partial rotate a) (partial add (minus r))))
(def TWO_PI (* 2 PI))
(defn regular-polygon [n]
(take (inc n)(iterate (partial rotate (/ TWO_PI n)) [1. 0])))
</code></pre>

<pre><code class="klipse">

(defn weighted-mean [t [p0 p1]]
(add (scale (- 1 t) p0) (scale t p1)))
(weighted-mean 0.25 [[0 1] [1 2]])
</code></pre>

<pre><code class="reagent">

(defn bezier-step [ps t]
(condp = (count ps)
1 (first ps)
2 (let[[p0 p1] ps] (weighted-mean t p0 p1))
3 (let[[p0 p1 p2] ps] (add (scale (* (- 1 t) (- 1 t)) p0) (add (scale (* 2 t (- 1 t)) p1) (scale (* t t) p2))))
(bezier-step (map (partial weighted-mean t) (partition 2 1 ps)) t)))

(defn bezier [n ps]
(if (< (count ps) 2) ps (mapv (comp (partial bezier-step ps) (partial * (/ 1 n))) (range (inc n)))))
(def ctrl-pts [[0 0][0 1][2 1]])
[draw-fitted-polylines [400 400] [ctrl-pts (bezier 16 ctrl-pts)]]
</code></pre>

<pre><code class="reagent">

(defn square-curve[n p0-p2 angle]
(let[inv-sqrt-2 (/ 1. (sqrt 2))
  p01 (weighted-mean inv-sqrt-2 p0-p2)
  p21 (weighted-mean (- 1. inv-sqrt-2) p0-p2)
  [p0 p2] p0-p2
  p1  (weighted-mean 0.5 [((make-rotate-around p0 (/ angle 2)) p01)
                          ((make-rotate-around p2 (/ angle -2)) p21)])]
                          (bezier n [p0 p1 p2])))

(defn square-with-curve [n angle]
(let[square (regular-polygon 4)]
[square (square-curve n [(first square)(nth square 2)] angle)]))
[draw-fitted-polylines [400 400] (square-with-curve 10 (/ PI 4))] 
</code></pre>

<pre><code class="reagent">

(defn power [x n] (nth (iterate (partial * x) 1) n))
(defn squares-params-f[angle invertRatio]
  (let[golden-ratio (/ 2. (+ 1. (sqrt 5)))
       [factor ratio a] (if invertRatio [-1 (/ 1. golden-ratio) angle ]
                                        [1 golden-ratio (- angle)])]
    [[] [(make-polylines-transform (comp (make-rotate-around [factor 0] a)
                                         (partial add [(* factor (+ 1. ratio)) 0])
                                         (partial scale ratio)))
         ;; should use (power ratio ?)
         (fn[n](square-with-curve (max 1 (if invertRatio (+ 10 n) (- 10 n))) 
                                  (* factor a)))]]))
[draw-fitted-polylines [400 400]
 (let[[init [step-f step-elts-f]] (squares-params-f (/ PI 4) false)]
     (step-f (step-elts-f 5)))]
</code></pre>

<pre><code class="reagent">

         (defn fractal-step-f [[step-f step-elts-f] [current-elts i]]
  (into (step-elts-f i) (step-f current-elts)))

(defn params->params-f [[init-elts [step-f step-elts]]] [init-elts [step-f (constantly step-elts)]])

(defn fractal-f [[init-elts step-params-f] details]
  (reduce (fn[current-elts i] (fractal-step-f step-params-f [current-elts i])) init-elts (range (dec details) -1 -1)))
[draw-fitted-polylines [400 400](fractal-f (squares-params-f (/ PI 4) false) 4)]
</code></pre>

<pre><code class="reagent">

(def golden-squares-state (reagent.core/atom {:angle (/ PI -2) }))
(defn gui-golden-squares[]
  (let[angle (:angle @golden-squares-state)]
    [:div 
     [:div [:input {:type "range" :value (:angle @golden-squares-state) :min (/ PI -2)  :max (/ PI 2)  :style {:width "90%"}
                    :on-change (fn[e] (swap! golden-squares-state assoc 
:angle (js/parseFloat (.-target.value e))))}]]
[draw-fitted-polylines [400 400](fractal-f (squares-params-f angle false) 4)]]))
</code></pre>

<pre><code class="reagent">

(defn centered-golden-squares[[dx zoom angle] [details-inc details-dec]]
((make-polylines-transform (comp (partial add [dx 0]) (partial rotate (/ angle -2)) (partial scale zoom)))
  (into (fractal-f (squares-params-f angle true) details-inc) (fractal-f (squares-params-f angle false) details-dec))))

(defn inclusive-range [n [[first last] times]]
(if (== times 1) (mapv (comp (partial + first) (partial * (/ (- last first) n))) (range (inc n)))
(into (inclusive-range (quot n times) [[first last] 1]) (inclusive-range (rem n times) [[last first] (dec times)]))))

(defn golden-squares-anim-params [n]
(let[ratio (/ (+ 1. (sqrt 5)) 2)]
(apply (partial mapv vector) (map (partial inclusive-range n) [[[1 (+ 1 ratio)] 1] [[1 (+ 1 (/ 0.5 ratio))] 1] [[(/ PI -2) (/ PI 2)] 2]]))))
(def data (golden-squares-anim-params 100))
[draw-fitted-polylines [400 400](centered-golden-squares (nth data 10) [4 4])]
</code></pre>

<script>
window.klipse_settings = {
  selector: '.klipse',
  selector_reagent: '.reagent'
};
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>

<p>
test
</p>
