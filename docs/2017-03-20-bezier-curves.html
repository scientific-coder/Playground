<!DOCTYPE html>
<html class='v2' dir='ltr'>
<head>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<title>Programming as Composing</title>

</head>

<link href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" rel="stylesheet" type="text/css"></link>
<style>
  body { background-color: #eeeeee; }
  pre, code { font-size: 16px; background-color: white; }
</style>


<pre style="display: none;"><code class="klipse">

(ns my.reagent-examples
  (:require
    [clojure.string :as string]
    [reagent.core :as reagent]
[reagent.ratom]))

(enable-console-print!)
(defn svg-polyline[ps]
(let[[[x0 y0] & ps] ps
init-point (str "M " x0 ", " y0 " ")
seg (fn[[x y]] (str "L " x ", " y " "))]
(reduce #(str %1 (seg %2)) init-point ps)))
(defn draw-polylines[[w h] pss]
          [:svg {:width w :height h}
          [:path {:stroke "black" :stroke-width 1 :fill "none" :d  (reduce str (map svg-polyline pss))}] ])
(defn add [[x0 y0][x1 y1]]
[(+ x0 x1)(+ y0 y1)])
(def make-polylines-transform (comp (partial partial mapv) (partial partial mapv) ))
(defn sin[x]
  (.sin js/Math x))
(defn cos[x]
          (.cos js/Math x))

(def PI
  (.-PI js/Math))
    (def sqrt #(.sqrt js/Math %))

    (defn rotate [a [x y]]
    (let [c (cos a)
          s (sin a)]
    [(- (* c x) (* s y)) (+ (* s x) (* c y))]))
(defn scale [k p]
(mapv (partial * k) p))
(def minus (partial scale -1.))
(def -INF (.-NEGATIVE_INFINITY js/Number))
(def INF (.-POSITIVE_INFINITY js/Number))

    (defn bounding-box[pss]
    (->> pss (reduce into [])(reduce (fn[[[x-min y-min][x-max y-max]][x y]] [[(min x-min x) (min y-min y)][(max x-max x)(max y-max y)]]) [[INF INF][-INF -INF]])))
      (defn make-fitting-transform[[w h] pss]
      (let[[[x-min y-min][x-max y-max]](bounding-box pss)
      s (min (/ w (- x-max x-min)) (/ h (- y-max y-min)))
      center (scale 0.5  (add [x-min y-min] [x-max y-max]))]
      (comp (partial add [(/ w 2) (/ h 2)]) (partial scale s) (partial add (minus center)))))
      (defn draw-fitted-polylines[wh pss]
      (draw-polylines wh ((make-polylines-transform (make-fitting-transform wh pss)) pss)))
(defn make-rotate-around [r a]
  (comp (partial add r)(partial rotate a) (partial add (minus r))))
(def TWO_PI (* 2 PI))
(defn regular-polygon [n]
(take (inc n)(iterate (partial rotate (/ TWO_PI n)) [1. 0])))
</code></pre>

<pre><code class="klipse">

(defn weighted-mean [t [p0 p1]]
(add (scale (- 1 t) p0) (scale t p1)))
(weighted-mean 0.25 [[0 1] [1 2]])
</code></pre>

<pre><code class="reagent">

(defn bezier-step [ps t]
(condp = (count ps)
1 (first ps)
2 (let[[p0 p1] ps] (weighted-mean t p0 p1))
3 (let[[p0 p1 p2] ps] (add (scale (* (- 1 t) (- 1 t)) p0) (add (scale (* 2 t (- 1 t)) p1) (scale (* t t) p2))))
(bezier-step (map (partial weighted-mean t) (partition 2 1 ps)) t)))

(defn bezier [n ps]
(if (< (count ps) 2) ps (mapv (comp (partial bezier-step ps) (partial * (/ 1 n))) (range (inc n)))))
(def ctrl-pts [[0 0][0 1][2 1]])
[draw-fitted-polylines [400 400] [ctrl-pts (bezier 16 ctrl-pts)]]
</code></pre>

<pre><code class="reagent">

(defn square-curve[n p0-p2 angle]
(let[inv-sqrt-2 (/ 1. (sqrt 2))
  p01 (weighted-mean inv-sqrt-2 p0-p2)
  p21 (weighted-mean (- 1. inv-sqrt-2) p0-p2)
  [p0 p2] p0-p2
  p1  (weighted-mean 0.5 [((make-rotate-around p0 (/ angle -2)) p01)
                          ((make-rotate-around p2 (/ angle 2)) p21)])]
                          (bezier n [p0 p1 p2])))

(defn square-with-curve [n angle]
(let[square (regular-polygon 4)]
[square (square-curve n [(first square)(nth square 2)] angle)]))
[draw-fitted-polylines [400 400] (square-with-curve 10 (/ PI 4))] 
</code></pre>

<script>
window.klipse_settings = {
  selector: '.klipse',
  selector_reagent: '.reagent'
};
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>

<p>
test
</p>
