<!DOCTYPE html>
<html class='v2' dir='ltr'>
<head>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<title>Testing Reagent with Klipse</title>

</head>

<link href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" rel="stylesheet" type="text/css"></link>

<style>
  body { background-color: #eeeeee; }
  pre, code { font-size: 16px; background-color: white; }
</style>

<br />
<pre style="display: none;"><code class="klipse">
(ns my.reagent-examples
  (:require
    [clojure.string :as string]
    [reagent.core :as reagent]
[reagent.ratom]))

(enable-console-print!)

</code></pre>
Goal :
<p/>
<a href="http://szimmetria-airtemmizs.tumblr.com/post/152193952943/tumbling-regular-polygons-i-started-drawing">
<img src="http://68.media.tumblr.com/daf492bdad5b7b6c09ca39f4d3e5aac9/tumblr_ofhtnaIpp21vq24vjo1_1280.gif"> 
</a>
<p/>
Building a svg path from a polyline (sequence of [x y] coords):
<pre><code class="klipse">
          (defn svg-polyline[ps]
          (let[[[x0 y0] & ps] ps
          init-point (str "M " x0 ", " y0 " ")
          seg (fn[[x y]] (str "L " x ", " y " "))]
          (reduce #(str %1 (seg %2)) init-point ps)))

          (svg-polyline [[10 10][10 20][20 20]])
</code></pre>
Displaying a sequence of polylines
<pre><code class="reagent">
(defn draw-polylines[[w h] pss]
          [:svg {:width w :height h}
          [:path {:stroke "black" :stroke-width 1 :fill "none" :d  (reduce str (map svg-polyline pss))}] ])


    [draw-polylines [300 300] [[[100 100][100 200][200 250]]]]
</code></pre>
Adding two vectors (points) 
<pre><code class="klipse">
    (defn add [[x0 y0][x1 y1]]
    [(+ x0 x1)(+ y0 y1)])
    (add [100 200] [10 20])
</code></pre>

Translating a polyline :
<pre><code class="klipse">
    (map (partial add [100 100]) [[10 20][20 30]])
</code></pre>
Drawing a translated polyline
<pre><code class="reagent">
    [draw-polylines [200 200] [ (mapv (partial add [100 50]) [[100 100][100 200][200 250]])]]
</code></pre>
Drawing a translated sequence of polylines
<pre><code class="reagent">
    [draw-polylines [400 400] (mapv (partial mapv (partial add [50 50] )) [[[100 100][100 200][200 250]] [[50 50][200 50][200 100]]])]
</code></pre>
Abstracting the transformation of a set of polylines with a function returning a function
<pre><code class="reagent">
    (defn make-polylines-transform [f]
    #(mapv (partial mapv f) %))

    [draw-polylines [400 400] ((make-polylines-transform (partial add [100 50])) [[[100 100][100 200][200 250]] [[50 50][200 50][200 100]]])]
</code></pre>
Abstracting the transformation of a set of polylines with a function using a higher order function 
<pre><code class="reagent">
    (defn make-polylines-transform [f]
    (partial mapv (partial mapv f) ))
    [draw-polylines [400 400] ((make-polylines-transform (partial add [100 50])) [[[100 100][100 200][200 250]] [[50 50][200 50][200 100]]])]
</code></pre>
Abstracting the transformation of a set of polylines composing higher order functions : point free 
<pre><code class="reagent">
    (def make-polylines-transform (comp (partial partial mapv) (partial partial mapv) ))
    [draw-polylines [400 400] ((make-polylines-transform (partial add [100 50])) [[[100 100][100 200][200 250]] [[50 50][200 50][200 100]]])]
</code></pre>
Rotating a vector
<pre><code class="klipse">
(defn sin[x]
  (.sin js/Math x))
(defn cos[x]
          (.cos js/Math x))

(def PI
  (.-PI js/Math))

    (defn rotate [a [x y]]
    (let [c (cos a)
          s (sin a)]
    [(- (* c x) (* s y)) (+ (* s x) (* c y))]))
    (rotate (/ PI 4) [10 20])
</code></pre>
Displaying a rotated sequence of polylines
<pre><code class="reagent">
    [draw-polylines [400 400] ((make-polylines-transform (partial rotate (/ PI 4))) [[[100 100][100 200][200 250]][[50 50][200 50][200 100]]])]
</code></pre>
Displaying a sequence of polylines transformed by a composition of (points) transformations
<pre><code class="reagent">
    [draw-polylines [400 400] ((make-polylines-transform (comp (partial add [100 100]) (partial rotate (/ PI 4)))) [[[100 100][100 200][200 250]][[50 50][200 50][200 100]]])]
</code></pre>
Scaling a vector
<pre><code class="klipse">
    (defn scale [k p]
    (mapv (partial * k) p))
    (scale 2 [10 20])
</code></pre>
Displaying a scaled sequence of polylines
<pre><code class="reagent">
    [draw-polylines [200 200] ((make-polylines-transform (partial scale 0.5)) [[[100 100][100 200][200 250]][[50 50][200 50][200 100]]])]
</code></pre>
Drawing a scaled and translated version of the given sequence of polylines so as to fit the given dimension 
<pre><code class="reagent">
(def -INF (.-NEGATIVE_INFINITY js/Number))
(def INF (.-POSITIVE_INFINITY js/Number))
(def minus (partial scale -1.))

    (defn bounding-box[pss]
    (->> pss (reduce into [])(reduce (fn[[[x-min y-min][x-max y-max]][x y]] [[(min x-min x) (min y-min y)][(max x-max x)(max y-max y)]]) [[INF INF][-INF -INF]])))
      (defn make-fitting-transform[[w h] pss]
      (let[[[x-min y-min][x-max y-max]](bounding-box pss)
      s (min (/ w (- x-max x-min)) (/ h (- y-max y-min)))
      center (scale 0.5  (add [x-min y-min] [x-max y-max]))]
      (comp (partial add [(/ w 2) (/ h 2)]) (partial scale s) (partial add (minus center)))))
      (defn draw-fitted-polylines[wh pss]
      (draw-polylines wh ((make-polylines-transform (make-fitting-transform wh pss)) pss)))
    [draw-fitted-polylines [200 200] ((make-polylines-transform (comp (partial add [100 100]) (partial rotate (/ PI 4)))) [[[10 10][10 20][20 25]][[5 5][20 5][20 10]]])]
</code></pre>
Regular polygons as polylines 
<pre><code class="reagent">
    (def TWO_PI (* 2 PI))
    (defn regular-polygon [n]
    (take (inc n)(iterate (partial rotate (/ TWO_PI n)) [1. 0])))
    [draw-fitted-polylines [200 200] (map regular-polygon (range 3 7))]
</code></pre>
Scaled regular polygons so that their sides are the same length regardless of the nb of sides 
<pre><code class="reagent">
    (defn scaled-regular-polygon [n]
    (mapv (partial scale (/ 1 (* 2 (sin (/ PI n))))) (regular-polygon n)))

    [draw-fitted-polylines [200 200] (map scaled-regular-polygon (range 3 7))]
</code></pre>
Translated polyline so that point n matches the same point of the reference polyline 
<pre><code class="reagent">
(defn polyline-matching-at[ps-ref n ps]
  (mapv (partial add (add (nth ps-ref (mod n (count ps-ref)))(minus (nth ps (mod n (count ps)))))) ps))

(def pss (map scaled-regular-polygon (range 3 7)))
(def pssf (map (partial polyline-matching-at (last pss) 0) pss))

[draw-fitted-polylines [200 200] pssf]
</code></pre>
Computing the angle between two vectors
<pre><code class="klipse">
    (def sqrt #(.sqrt js/Math %))
    (def acos #(.acos js/Math %))
    (def asin #(.asin js/Math %))
    (def atan2 #(.atan2 js/Math %1 %2))

    (defn cross-product[[x0 y0][x1 y1]]
    (+  (* x0 x1) (* y0 y1)))
    (defn dot-product [[x0 y0][x1 y1]]
    (+ (* x0 x1) (* y0 y1)))
    (defn magnitude[p]
    (sqrt (cross-product p p))) 
    (defn angle[[xr yr][x y]]
    (- (atan2 y x) (atan2 yr xr)))
    (angle [1 0] [0 1])
</code></pre>
Rotating around a given center

Computing the difference of two angles (taking care of the modulo)

Transforming a polyline so that given (integral part) point matches and that the angle is proportional to the non integral part.
<pre><code class="reagent">
(defn make-rotate-around [r a]
  (comp (partial add r)(partial rotate a) (partial add (minus r))))
(defn mod+ [a b]
  (let [r (mod a b)]
    (if (neg? r) (+ b r) r)))
(defn diff-mod[a b m]
  (let [dab (mod+ (- a b) m)
        dba (mod+ (- b a) m)]
  (if (< dab dba)
    (- dab)
    dba))) 
(defn polyline-angling-at[rs f ps]
  (let[n (int (+ f 0.5))
       a-f (* (+ (- f n) 0.5) 1)
       get-pts (fn[xys](map #(nth xys (mod (+ n %) (dec (count xys)))) [-1 0 1]))
       [r-1 r r+1] (get-pts rs)
       [p-1 p p+1] (get-pts ps)
       a+1 (- (angle (add r+1 (minus r)) (add p+1 (minus p))))
       a-1 (- (angle (add r-1 (minus r)) (add p-1 (minus p))))
       a (+ a-1 (* a-f (diff-mod a-1 a+1 TWO_PI)))]
    (mapv (comp (make-rotate-around r a) (partial add (add r (minus p)))) ps)))

(def pss (map scaled-regular-polygon (range 3 12)))
(def pssf (mapv (partial polyline-angling-at (last pss) 1.5) (butlast pss)))

         [draw-fitted-polylines [200 200] (conj pssf (last pss))]
         </code></pre>
GUI controls for the parameters
<pre><code class="reagent">

(def state (reagent.core/atom {:n-sides-min 3 :n-sides-max 10 :step 0.}))

(defn slider [param value min-v max-v]
  [:input {:type "range" :value value :min min-v :max max-v :step (if (= :step param) 0.01 1)
           :style {:width "90%"}
           :on-change (fn [e]
                        (swap! state assoc param (js/parseFloat (.-target.value e)))
                        (let[{:keys [n-sides-min n-sides-max step]} @state]
                          (condp = param
                            :n-sides-min (swap! state assoc :n-sides-max (max n-sides-min n-sides-max))
                            :n-sides-max (swap! state assoc :n-sides-min (min n-sides-min n-sides-max)))))}])

(defn ctrl-component[]
  (let[{:keys [n-sides-min n-sides-max step]} @state ]
    [:div 
     [:div
      "min : " (int n-sides-min) " "
      [slider :n-sides-min n-sides-min 3 n-sides-max]]
     [:div
      "max : " (int n-sides-max) " "
      [slider :n-sides-max n-sides-max n-sides-min 16]]
     [:div
      "step : " step " "
      [slider :step step 0 (* 2 n-sides-max)]]
     ]))
</code></pre>
Drawing according to the GUI controls
<pre><code class="reagent">
    (defn poly-component[]
    (let[{:keys [n-sides-min n-sides-max step]} @state
    pss (map scaled-regular-polygon (range n-sides-min (inc n-sides-max)))
    pssf (mapv (partial polyline-angling-at (last pss) step) (butlast pss)) ]
    [draw-fitted-polylines [400 400] (conj pssf (last pss))]
    ))
</code></pre>
Unfolding a polyline of two segments
<pre><code class="reagent">
(defn interpolate-angles [f a0 a1]
  (+ a0 (* f (diff-mod a0 a1 TWO_PI))))
(defn unfold-segments[f [p0 p1 p2]]
  (let[mp1 (minus p1)
       a (angle (add p0 mp1) (add p2 mp1))
       da (interpolate-angles f (- PI a) 0)]
    [p0 p1 ((make-rotate-around p1 da) p2)]))


[draw-fitted-polylines [100 100] [(unfold-segments 0.5 [[10 10][10 20] [20 30]])]]
</code></pre>

Unfolding a polyline
Bad algorithmic complexity !
TODO : make it actually linear (switching to matrix representations of transformations )
<pre><code class="reagent">
(defn make-unfolding-transform[f [p0 p1 p2]]
                               (let[mp1 (minus p1)]	
                                 (make-rotate-around p1 (interpolate-angles f (- PI (angle (add p0 mp1) (add p2 mp1))) 0))))
(defn unfold-segments-2[f [p0 p1 p2]]
  [p0 p1 ((make-unfolding-transform f [p0 p1 p2]))]) 
(defn unfold-polyline[f ps]
  (let[f (min (/ f (dec (count ps))) 1.)
       transforms (reductions comp identity (map (partial make-unfolding-transform f) (partition 3 1 ps)))]
    (into [(first ps)] (map #(%1 %2) transforms (rest ps)))))  
[draw-fitted-polylines [200 200] (map (comp (partial unfold-polyline 5.) scaled-regular-polygon) (range 3 8))]
</code></pre>

<pre><code class="reagent">
    (def f 1.5) 
(def pss (map (comp (partial unfold-polyline f) scaled-regular-polygon) (range 3 12)))
(def pssf (mapv (partial polyline-angling-at (last pss) f) (butlast pss)))

         [draw-fitted-polylines [200 200] (conj pssf (last pss))]
         </code></pre>

<pre><code class="reagent">
(defn folding-gui[]
    (let[{:keys [n-sides-min n-sides-max step]} @state ]
    [:div 
     [:div
      "min : " (int n-sides-min) " "
      [slider :n-sides-min n-sides-min 3 n-sides-max]]
     [:div
      "max : " (int n-sides-max) " "
      [slider :n-sides-max n-sides-max n-sides-min 16]]
     [:div
      "step : " step " "
      [slider :step step 0 (* 2 n-sides-max)]]
[:div
    (let[pss (map (comp (partial unfold-polyline (inc step)) scaled-regular-polygon) (range n-sides-min n-sides-max))
         pssf (mapv (partial polyline-angling-at (last pss) step) (butlast pss))]

         [draw-fitted-polylines [400 400] (conj pssf (last pss))])]]))
         </code></pre>

<pre><code class="reagent">
         (defn fractal-step [[step-f step-elts] current-elts]
  (into step-elts (step-f current-elts)))

(defn fractal [[init-elts step-params] details]
  (nth (iterate (partial fractal-step step-params) init-elts) details))

         (defn merged-juxt[fs]
         (comp (partial reduce into [])(apply juxt fs)))

(defn sierpinski-params [n]
  (let[step-elt (regular-polygon n)
       make-transform #(make-polylines-transform (comp (partial add %)
                                                       (partial scale (/ 1 (dec n)))))]
  (condp = n
    3 [[]
       [(merged-juxt (for [i [0 1 2]] (make-transform (rotate (+ PI (* i 2 (/ PI 3))) [1. 0.]))))
        [step-elt]]]
    4 [[]
       [(merged-juxt (let [d [-1 0 1]]
                       (for [dx d dy d :when (not= 0 dx dy)]
                         (make-transform (scale (sqrt 2.) [dx dy])))))
        [(map (partial rotate (/ PI 4)) step-elt)]]])))

[draw-fitted-polylines [400 400] (fractal (sierpinski-params 3) 6)]
</code></pre>
<pre><code class="reagent">

[draw-fitted-polylines [400 400] (fractal (sierpinski-params 4) 5)]
</code></pre>

<pre><code class="reagent">
(defn tree-params [angles]
  (let[branch [0 -1]
       ratio (/ (+ 1 (sqrt 5.)) 2.)]
    [[]
     [(merged-juxt (for [a angles]
                     (make-polylines-transform
                                             (comp (partial add branch)
                                                      (partial scale (/ 1 ratio))
                                                      (partial rotate a)))))
      [[[0. 0] branch]]]]))


[draw-fitted-polylines [400 400] (fractal (tree-params [(/ PI 6)(/ PI -3)]) 8)]
</code></pre>

<pre><code class="reagent">
(def koch-params [[[[-0.5 0][0.5 0]]]
                  [(merged-juxt (for [[v a] [[[(/ -1 3) 0] 0]
                                             [[(/ 1 3) 0] 0]
                                             [(rotate (/ PI -3) [(/ 1 6) 0]) (/ PI 3)]
                                             [(rotate (/ PI 3) [(/ -1 6) 0]) (/ PI -3)]]]
                                        (make-polylines-transform (comp (partial add v)
                                                                   (partial rotate a)
                                                                   (partial scale (/ 1 3))))))
                   []]])
[draw-fitted-polylines [400 400] (fractal koch-params 4)]
</code></pre>

<pre><code class="reagent">
    ;; hilbert is special because there is only one polyline. We do not transform and merge sequences of polylines but transform and merge polylines (sequences of points). Also, the initial polyline is only one point long.
(def hilbert-transform
    (comp (merged-juxt
            [(comp (partial mapv (comp (partial add [-0.5 0.5]) (partial rotate (/ PI 2)))) reverse)
             (partial mapv (partial add [-0.5 -0.5]))
        	 (partial mapv (partial add [0.5 -0.5]))
             (comp (partial mapv (comp (partial add [0.5 0.5]) (partial rotate (/ PI -2)))) reverse)])
          (partial mapv (partial scale 0.5))))

    [draw-fitted-polylines [400 400] [(nth (iterate hilbert-transform [[0 0]]) 5)]]
</code></pre>
<pre><code class="reagent">
    (def hilbert-params [[[[0 0]]] [(partial mapv hilbert-transform) []]])
[draw-fitted-polylines [400 400] (fractal hilbert-params 6)]
</code></pre>


<a href="https://scientific-coder.github.io/fractals/resources/public/fractals.html">

TO BE CONTINUED…
</a>
<pre class="hidden"><code class="klipse">
(defn apply-to-polyline-f3[f p ps](map (partial f p) ps))
(apply-to-polyline-f3 add [100 100] [[10 20][20 30]])
(defn f2 [f p](partial map (partial f p)))
((f2 add [100 100]) [[10 20][20 30]])
(defn f1 [f] (comp (partial partial map)(partial partial f)))
(((f1 add) [100 100])[[10 20][20 30]])
(def to-polyline (comp (partial comp (partial partial map))(partial partial partial)))
(((to-polyline add)[100 100])[[10 20][20 30]])
    (map (partial rotate (/ PI 4)) [[10 20][20 30]])
</code></pre>

<script>
window.klipse_settings = {
  selector: '.klipse',
  selector_reagent: '.reagent'
};
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>



