#+PROPERTY: BLOG Test subtree export
#+OPTIONS: toc:nil 
 # I have no idea why the jekyll layout does not work for me ☹
#+name: inline-html-header
#+begin_src elisp :exports none :results html :var url="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"

"<!DOCTYPE html>
<html class='v2' dir='ltr'>
<head>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<title>Programming as Composing</title>

</head>"
#+end_src


#+name: inline-klipse-header
#+begin_src elisp :exports none :results html :var url="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"
(concat
"<link href=\"" url "\" rel=\"stylesheet\" type=\"text/css\"></link>
<style>
  body { background-color: #eeeeee; }
  pre, code { font-size: 16px; background-color: white; }
</style>")
#+end_src


#+name: inline-klipse-footer
#+begin_src elisp :exports none :results html :var url="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"
(concat "<script>
window.klipse_settings = {
  selector: '.klipse',
  selector_reagent: '.reagent'
};
</script>
<script src=\"" url "\"></script>")
#+end_src



http://emacs.stackexchange.com/a/28387


#+name: inline-klipse-clojure
#+begin_src elisp :exports none :results html :var blk=""
(concat
 "<pre><code class=\"klipse\">\n"
 (cadr (org-babel-lob--src-info blk))
 "\n"
 "</code></pre>")
#+end_src
#+name: inline-klipse-clojure-s
#+begin_src elisp :exports none :results html :var blks='("")
(setq res "")
(concat
 "<pre><code class=\"klipse\">\n"
(dolist (blk blks res)
  (setq res (concat res "\n" (cadr (org-babel-lob--src-info blk)))))
 "\n"
 "</code></pre>")
#+end_src
should really be an optional boolean parameter of inline-klipse-clojure ! 
#+name: inline-hidden-klipse-clojure
#+begin_src elisp :exports none :results html :var blk=""
(concat
 "<pre style=\"display: none;\"><code class=\"klipse\">\n"
 (cadr (org-babel-lob--src-info blk))
 "\n"
 "</code></pre>")
#+end_src

#+name: inline-hidden-klipse-clojure-s
#+begin_src elisp :exports none :results html :var blks='("")
(setq res "")
(concat
 "<pre style=\"display: none;\"><code class=\"klipse\">\n"
(dolist (blk blks res)
  (setq res (concat res "\n" (cadr (org-babel-lob--src-info blk)))))
 "\n"
 "</code></pre>")
#+end_src

#+name: inline-klipse-reagent
#+begin_src elisp :exports none :results html :var blk=""
(concat
 "<pre><code class=\"reagent\">\n"
 (cadr (org-babel-lob--src-info blk))
 "\n"
 "</code></pre>")
#+end_src

#+name: inline-klipse-reagent-s
#+begin_src elisp :exports none :results html :var blks='("")
(setq res "")
(concat
 "<pre><code class=\"reagent\">\n"
(dolist (blk blks res)
  (setq res (concat res "\n" (cadr (org-babel-lob--src-info blk)))))
  "\n"
 "</code></pre>")
#+end_src

#+name: foo
#+begin_src clojure :exports none
(+ 1 1)
#+end_src

#+name: bar
#+begin_src clojure :exports none
(+ 2 2)
#+end_src

http://endlessparentheses.com/how-i-blog-one-year-of-posts-in-a-single-org-file.html

https://github.com/yoshinari-nomura/org-octopress/blob/master/ox-jekyll.el

#+NAME: init-reagent-examples
#+BEGIN_SRC clojure :exports none
(ns my.reagent-examples
  (:require
    [clojure.string :as string]
    [reagent.core :as reagent]
[reagent.ratom]))

(enable-console-print!)
#+END_SRC

#+NAME: src-dynamic-homoiconicity
#+BEGIN_SRC clojure :exports none
(defn comp [& fs]
(with-meta (apply
(fn ([] identity)
  ([f] f)
  ([f g] 
     (fn 
       ([] (f (g)))
       ([x] (f (g x)))
       ([x y] (f (g x y)))
       ([x y z] (f (g x y z)))
       ([x y z & args] (f (apply g x y z args)))))
  ([f g & fs]
(reduce comp (list* f g fs))))
 fs)
    {:is-from comp
:args fs}))

(defn partial [& args]
(with-meta (apply (fn
([f] f)
  ([f arg1]
   (fn
     ([] (f arg1))
     ([x] (f arg1 x))
     ([x y] (f arg1 x y))
     ([x y z] (f arg1 x y z))
     ([x y z & args] (apply f arg1 x y z args))))
  ([f arg1 arg2]
   (fn
     ([] (f arg1 arg2))
     ([x] (f arg1 arg2 x))
     ([x y] (f arg1 arg2 x y))
     ([x y z] (f arg1 arg2 x y z))
     ([x y z & args] (apply f arg1 arg2 x y z args))))
  ([f arg1 arg2 arg3]
   (fn
     ([] (f arg1 arg2 arg3))
     ([x] (f arg1 arg2 arg3 x))
     ([x y] (f arg1 arg2 arg3 x y))
     ([x y z] (f arg1 arg2 arg3 x y z))
     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))
  ([f arg1 arg2 arg3 & more]
(fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))
args)
    {:is-from partial
     :args args}))


(defn mapv [& args]
(with-meta (apply (fn
  ([f coll]
     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)
         persistent!))
  ([f c1 c2]
     (into [] (map f c1 c2)))
  ([f c1 c2 c3]
     (into [] (map f c1 c2 c3)))
  ([f c1 c2 c3 & colls]
     (into [] (apply map f c1 c2 c3 colls))))
args)
    {:is-from mapv}))

(defn merged-juxt[fs]
  (with-meta (comp (partial reduce into []) (apply juxt fs))
    {:is-from merged-juxt
     :args fs}))

#+END_SRC
 
#+NAME: src-svg-polyline
#+BEGIN_SRC clojure :exports none
          (defn svg-polyline[ps]
          (let[[[x0 y0] & ps] ps
          init-point (str "M " x0 ", " y0 " ")
          seg (fn[[x y]] (str "L " x ", " y " "))]
          (reduce #(str %1 (seg %2)) init-point ps)))
#+END_SRC
#+NAME: src-svg-polyline-use
#+BEGIN_SRC clojure :exports none
          (svg-polyline [[10 10][10 20][20 20]])
#+END_SRC
#+NAME: src-draw-polylines
#+BEGIN_SRC clojure :exports none
(defn draw-polylines[[w h] pss]
          [:svg {:width w :height h}
          [:path {:stroke "black" :stroke-width 1 :fill "none" :d  (reduce str (map svg-polyline pss))}] ])
#+END_SRC

#+NAME: src-draw-polylines-use
#+BEGIN_SRC clojure :exports none
[draw-polylines [300 300] [[[100 100][100 200][200 250]]]]
#+END_SRC

#+NAME: src-add
#+BEGIN_SRC clojure :exports none
    (defn add [[x0 y0][x1 y1]]
    [(+ x0 x1)(+ y0 y1)])
#+END_SRC

#+NAME: src-add-use
#+BEGIN_SRC clojure :exports none
    (add [100 200] [10 20])
#+END_SRC


#+NAME: src-make-polylines-transform
#+BEGIN_SRC clojure :exports none
    (def make-polylines-transform (comp (partial partial mapv) (partial partial mapv) ))
#+END_SRC

#+NAME: src-make-polylines-transform-use
#+BEGIN_SRC clojure :exports none
    [draw-polylines [400 400] ((make-polylines-transform (partial add [100 50])) [[[100 100][100 200][200 250]] [[50 50][200 50][200 100]]])]
#+END_SRC


#+NAME: src-rotate
#+BEGIN_SRC clojure :exports none
(defn sin[x]
  (.sin js/Math x))
(defn cos[x]
          (.cos js/Math x))

(def PI
  (.-PI js/Math))
    (def sqrt #(.sqrt js/Math %))

    (defn rotate [a [x y]]
    (let [c (cos a)
          s (sin a)]
    [(- (* c x) (* s y)) (+ (* s x) (* c y))]))
#+END_SRC

#+NAME: src-rotate-use
#+BEGIN_SRC clojure :exports none
    (rotate (/ PI 4) [10 20])
#+END_SRC

#+NAME: src-regular-polygon
#+BEGIN_SRC clojure :exports none
    (def TWO_PI (* 2 PI))
    (defn regular-polygon [n]
    (take (inc n)(iterate (partial rotate (/ TWO_PI n)) [1. 0])))
#+END_SRC

#+NAME: src-regular-polygon-use
#+BEGIN_SRC clojure :exports none
    [draw-fitted-polylines [200 200] (map regular-polygon (range 3 7))]
#+END_SRC


#+NAME: src-scale
#+BEGIN_SRC clojure :exports none
    (defn scale [k p]
    (mapv (partial * k) p))
    (def minus (partial scale -1.))
#+END_SRC

#+NAME: src-scale-use
#+BEGIN_SRC clojure :exports none
    (scale 2 [10 20])
#+END_SRC


#+NAME: src-draw-fitted-polylines
#+BEGIN_SRC clojure :exports none
(def -INF (.-NEGATIVE_INFINITY js/Number))
(def INF (.-POSITIVE_INFINITY js/Number))

    (defn bounding-box[pss]
    (->> pss (reduce into [])(reduce (fn[[[x-min y-min][x-max y-max]][x y]] [[(min x-min x) (min y-min y)][(max x-max x)(max y-max y)]]) [[INF INF][-INF -INF]])))
      (defn make-fitting-transform[[w h] pss]
      (let[[[x-min y-min][x-max y-max]](bounding-box pss)
      s (min (/ w (- x-max x-min)) (/ h (- y-max y-min)))
      center (scale 0.5  (add [x-min y-min] [x-max y-max]))]
      (comp (partial add [(/ w 2) (/ h 2)]) (partial scale s) (partial add (minus center)))))
      (defn draw-fitted-polylines[wh pss]
      (draw-polylines wh ((make-polylines-transform (make-fitting-transform wh pss)) pss)))
#+END_SRC

#+NAME: src-draw-fitted-polylines-use
#+BEGIN_SRC clojure :exports none
    [draw-fitted-polylines [200 200] ((make-polylines-transform (comp (partial add [100 100]) (partial rotate (/ PI 4)))) [[[10 10][10 20][20 25]][[5 5][20 5][20 10]]])]
#+END_SRC


#+NAME: src-make-rotate-around
#+BEGIN_SRC clojure :exports none
(defn make-rotate-around [r a]
  (comp (partial add r)(partial rotate a) (partial add (minus r))))
#+END_SRC

#+NAME: src-make-rotate-around-use
#+BEGIN_SRC clojure :exports none
((make-rotate-around [1 0] (/ PI 2)) [2 0])
#+END_SRC


 # Finally figured out how to factor some org fragment
#+NAME: text-test
#+BEGIN_SRC sh :output :results raw  :exports none
cat<<EOF
This is an *org* fragment
With
 \alpha text^{sup}
EOF
#+END_SRC


* DONE spirographs  
  CLOSED: [2017-03-19 Sun 22:20] SCHEDULED: <2017-03-19 Sun>
  :PROPERTIES:
  :EXPORT_JEKYLL_LAYOUT:
  :filename: 2017-03-19-spirographs
  :END:

#+call: inline-html-header()
#+call: inline-klipse-header()

 

#+NAME: src-spirograph
#+BEGIN_SRC clojure :exports none
  (defn spirograph[rks]
    (fn[a]
      (into [[(- (reduce + (map first rks))) 0]]
            (first (reduce (fn[[res c][r k]]
                             (let[next-c (- c r)]
                               [(map (make-rotate-around [next-c 0] (* k a))
                                     (conj res [c 0])) next-c]))
                           ['() 0]
                           (reverse rks))))))
#+END_SRC

#+NAME: src-spirograph-use
#+BEGIN_SRC clojure :exports none
[:div
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[50 1][45 -4]]) (partial * PI (/ 1 256))) (range 512)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[50 1][45 -3.25]]) (partial * PI 4 (/ 1 256))) (range 512)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[1 1][(/ 1. 2) -7]]) (partial * PI  (/ 1 256))) (range 512)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[1  1][(/ 1. 2) 4]]) (partial * PI (/ 1. 256))) (range 512)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[1  1][(/ 1. 2) 4][ (/ 1. 6) 16]]) (partial * PI  (/ 1. 256))) (range 513)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[1  1][(/ 1. 2) 8][ (/ 1. 6) 16]]) (partial * PI  (/ 1. 256))) (range 513)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph [[1  1][(/ 1. 2) 2][(/ 1. 4) 6][ (/ 1. 4) 5]]) (partial * PI  (/ 1. 256))) (range 513)))]]
 ]
#+END_SRC

#+NAME:src-spiro-1-spiro-2
#+BEGIN_SRC clojure :exports none
(defn spiro-1[n]
  (let[c (/ (condp = n
              10 15
              8 4
              9 10
              20 25
              15)
            200)
       a (/ (+ 1 c) 2)
       b-size (+ 1 (/ (sqrt 2) 2))
       c-size (/ (- 2 (sqrt 2)) 4)
       b-c-ratio (/ b-size c-size)
       b (/ (- 1 a) (+ 1. (/ 1 b-c-ratio)))]
    [[a 1][b (- n)][(/ b b-c-ratio) (* 4 n)]]))

(def spiro-2 (let[m (/ 1 (+ 3 (/ 1 3)))
                  s (/ m 6)][[(+ (* 2 m) s) 1][m -12][s (* 6 12)]]))
#+END_SRC

#+NAME:src-spiro-1-spiro-2-use
#+BEGIN_SRC clojure :exports none
[:div
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph (spiro-1 10)) (partial * PI (/ 1 256))) (range 513)))]]
 [draw-fitted-polylines [200 200] [(mapv last (map (comp (spirograph spiro-2) (partial * PI  (/ 1 256))) (range 512)))]]]
#+END_SRC

#+NAME: src-gui-spiro
#+BEGIN_SRC clojure :exports none
(def curves (mapv (fn[[rks n]] 
(mapv (comp (spirograph rks) (partial * PI (/ n 256))) (range 513)))
                  [[[[50 1][45 -4]] 1]
                   [[[50 1][45 -3.25]] 4]
                   [[[1 1][(/ 1. 2) -7]] 1]
                   [[[1  1][(/ 1. 2) 4]] 1]
                   [[[1  1][(/ 1. 2) 4][ (/ 1. 6) 16]] 1]
                   [[[1  1][(/ 1. 2) 8][ (/ 1. 6) 16]] 1]
                   [[[1  1][(/ 1. 2) 2][(/ 1. 4) 6][ (/ 1. 4) 5]] 1]
                   [(spiro-1 10) 1]
                   [spiro-2 1]]))

(def wh [120 120])
(def fitting-transforms (mapv (comp make-polylines-transform 
(partial make-fitting-transform wh) 
vector 
(partial mapv last)) curves)) 
(defn arm+curve[pps n] [(nth pps n) (mapv last (take n pps))])
(def spirograph-state (reagent.core/atom {:step 200}))
(defn gui-spiro1[]
  (let[step (:step @spirograph-state)]
    [:div 
     [:div [:input {:type "range" :value (:step @spirograph-state) :min 0  :max 512  :style {:width "90%"}
                    :on-change (fn[e] (swap! spirograph-state assoc 
:step (int (js/parseFloat (.-target.value e)))))}]]
     (into [:div]
           (map (fn[i](let[c (nth curves i)]
                        [draw-polylines (map (partial * 1.2) wh)
                        ((nth fitting-transforms i) 
                        (arm+curve c (:step @spirograph-state)))]))
                        (range (count curves))))]))
#+END_SRC

#+NAME: src-gui-spiro-use
#+BEGIN_SRC clojure :exports none
(defn gui-spiro1[]
  (let[step (:step @spirograph-state)]
    [:div 
     [:div [:input {:type "range" :value (:step @spirograph-state) :min 0  :max (* 1 520)  :style {:width "90%"}
                    :on-change (fn[e] (swap! spirograph-state assoc :step (int (js/parseFloat (.-target.value e)))))}]]
     (into [:div]
           (map (fn[i](let[c (nth curves i)]
                        [draw-polylines (map (partial * 1.2) wh) ((nth fitting-transforms i) 
(arm+curve c (:step @spirograph-state)))])) (range (count curves))))]))
#+END_SRC

#+call: inline-hidden-klipse-clojure-s('("init-reagent-examples" "src-svg-polyline" "src-draw-polylines" "src-add" "src-make-polylines-transform"  "src-rotate" "src-scale" "src-draw-fitted-polylines" "src-make-rotate-around" "src-spirograph" "src-spiro-1-spiro-2" "src-gui-spiro"))

The nice thing about drawing is that one can easily draw nice patterns, using compositions of primitive patterns.


One of the most elementary "pattern" would be the circle, with the most basic [[https://en.wikipedia.org/wiki/Circular_symmetry][Circular symmetry]].


 While a plain circle is not that pretty, just composing a few of them with spirographs
 can result in pretty drawings :

#+call: inline-klipse-reagent-s('("src-gui-spiro" "src-gui-spiro-use"))

Of course, some parameters make for prettier drawings :

#+call: inline-klipse-reagent-s('("src-spiro-1-spiro-2" "src-spiro-1-spiro-2-use"))

So what is a spirograph ? We want to have a function \( \alpha \rightarrow [x y] \) and the function will be parametrized by a sequence of [radius angular-velocity].

It is easier to go backward, from the last radius to the first, each time *composing* rotatations around the previous center.

#+call: inline-klipse-reagent-s( '("src-spirograph"  "src-spirograph-use"))


How does one rotate a point around any center ? By *composing* translations and rotation around the origin.

As we will *compose* the resulting function, we might as well write a /make-XXX/ that returns the rotating function curryfied / partially applied to the rotation center and the angle.
Instead, we could define a function taking all three parameters (rotation center, angle, and point to be rotated) and partially apply it each time we want to compose it.
 
#+call: inline-klipse-clojure-s( '("src-make-rotate-around"  "src-make-rotate-around-use"))

The rotation of a point around the origin is trivially defined.

#+call: inline-klipse-clojure-s( '("src-rotate"  "src-rotate-use"))

As we want to be able to display drawing in canvas of a given size, we *compose* scaling and translating the polylines so that it fits the canvas.

#+call: inline-klipse-reagent-s( '("src-draw-fitted-polylines"  "src-draw-fitted-polylines-use"))

Scaling from the origin is trivially defined. We might as well define a unary minus while we are at it.

#+call: inline-klipse-clojure-s( '("src-scale"  "src-scale-use"))

Adding two vectors in the usual trivial way.

#+call: inline-klipse-clojure-s('("src-add" "src-add-use"))


We are interested in transforming drawings. Drawings are sequences (vectors) of polylines, and polylines are vectors of points (and points are vectors of coords [x y] ).

So we can easily make a drawing-transforming function from a point-transforming function by *composing* sequence traversals and the given point-transforming function.
We can even do it in a [[https://en.wikipedia.org/wiki/Tacit_programming][tacit]] way, which will be useful for other purposes (but for now, any "equivalent" definition would do).
 
#+call: inline-klipse-reagent-s( '("src-make-polylines-transform"  "src-make-polylines-transform-use"))

Actually drawing (as in "displaying") the drawing is creating the svg fragment by concatenating the svg fragments for each polyline.
TODO: check for empty drawing !

#+call: inline-klipse-reagent-s('("src-draw-polylines" "src-draw-polylines-use"))

The svg fragment for a polyline is just concatenating a =Move= to the first point and =Line= to each of the remain points.

TODO: check for empty polyline !

#+call: inline-klipse-clojure-s( '("src-svg-polyline"  "src-svg-polyline-use"))


#+call: inline-klipse-footer()



* DONE Fractals
  CLOSED: [2017-03-20 Mon 01:34] SCHEDULED: <2017-03-20 Mon>
  :PROPERTIES:
  :EXPORT_JEKYLL_LAYOUT:
  :filename: 2017-03-20-fractals
  :END:

#+NAME: src-gui-fractals
#+BEGIN_SRC clojure :exports none
    (def memo-fractal (memoize fractal))
    (def fractal-name->params { "hilbert-curve" hilbert-params
                                                      "tree" (tree-params [(/ PI 6) (/ PI -3)])
                                                      "sierp-3" (sierpinski-params 3)
                                                      "sierp-4" (sierpinski-params 4)
      "koch" koch-params
      "koch-line" koch-line-params
      })
(def fractal-state (reagent.core/atom {:params (first (vals fractal-name->params)) :step 0}))
(defn gui-fractals[]
  (let[{:keys [params step]} @fractal-state]
    [:div
     [:div (into [:select {:on-change (fn[e] (swap! fractal-state assoc :params (get fractal-name->params (.-target.value e))))}]
           (mapv (fn[k] [:option {:value k} k]) (keys fractal-name->params)))]
     [:div [:input {:type "range" :value (:step @fractal-state) :min 0 :max 6  :style {:width "90%"}
              :on-change (fn[e] (swap! fractal-state assoc :step (js/parseFloat (.-target.value e))))}]]
     [draw-fitted-polylines [400 400] (memo-fractal params (int step))]]))
#+END_SRC

#+NAME: src-gui-fractals-use
#+BEGIN_SRC clojure :exports none
(defn gui-fractals[]
  (let[{:keys [params step]} @fractal-state]
    [:div
     [:div (into [:select {:on-change (fn[e] (swap! fractal-state assoc :params (get fractal-name->params (.-target.value e))))}]
           (mapv (fn[k] [:option {:value k} k]) (keys fractal-name->params)))]
     [:div [:input {:type "range" :value (:step @fractal-state) :min 0 :max 6  :style {:width "90%"}
              :on-change (fn[e] (swap! fractal-state assoc :step (js/parseFloat (.-target.value e))))}]]
     [draw-fitted-polylines [400 400] (memo-fractal params (int step))]]))
#+END_SRC

#+NAME: src-gui-fractals-with-steps
#+BEGIN_SRC clojure :exports none
    (def memo-fractal-with-steps (memoize fractal-with-steps)) ;; not so sure about a memo with a float arg ! :(
(def fractal-with-steps-state (reagent.core/atom {:params (first (vals fractal-name->params)) :step 0}))
(defn gui-fractals-stepified[]
  (let[{:keys [params step]} @fractal-with-steps-state]
    [:div
     [:div (into [:select {:on-change (fn[e] (swap! fractal-with-steps-state assoc :params (get fractal-name->params (.-target.value e))))}]
           (mapv (fn[k] [:option {:value k} k]) (keys fractal-name->params)))]
     [:div [:input {:type "range" :value (:step @fractal-with-steps-state) :step 0.01 :min 0 :max 6  :style {:width "90%"}
              :on-change (fn[e] (swap! fractal-with-steps-state assoc :step (js/parseFloat (.-target.value e))))}]]
     [draw-fitted-polylines [400 400] (memo-fractal-with-steps params step)]]))

#+END_SRC

#+NAME: src-gui-fractals-with-steps-use
#+BEGIN_SRC clojure :exports none
(defn gui-fractals-stepified[]
  (let[{:keys [params step]} @fractal-with-steps-state]
    [:div
     [:div (into [:select {:on-change (fn[e] (swap! fractal-with-steps-state assoc :params (get fractal-name->params (.-target.value e))))}]
           (mapv (fn[k] [:option {:value k} k]) (keys fractal-name->params)))]
     [:div [:input {:type "range" :value (:step @fractal-with-steps-state) :step 0.01 :min 0 :max 6  :style {:width "90%"}
              :on-change (fn[e] (swap! fractal-with-steps-state assoc :step (js/parseFloat (.-target.value e))))}]]
     [draw-fitted-polylines [400 400] (memo-fractal-with-steps params step)]]))

#+END_SRC

#+NAME: src-fractal-with-steps
#+BEGIN_SRC clojure :exports none
(defn sequence-steps [n step-factor]
  (let [p (* n step-factor)]
    (map #(-> (- p %) (min 1) (max 0)) (range n))))

(defn is-from [v]
  (get (meta v) :is-from :default))

(defn get-args [v]
  (:args (meta v)))

(defmulti stepify (fn [s v] (is-from v)))

(defmethod stepify :default [s v]
  v)

(defmethod stepify partial [s p]
  (let [args (get-args p)
        arg0 (first args)]
    (condp = arg0
      add (partial add (scale s (second args)))
      rotate (partial rotate (* (second args) s))
      scale (partial scale (js/Math.pow (second args) s))
      mapv (partial mapv (stepify s (second args)))
      :default (apply p (map (partial stepify s))))))

(defmethod stepify comp [s c]
  (let [args (get-args c)]
    (apply comp (map stepify
                        (reverse (sequence-steps (count args) s))
                        args))))

(defmethod stepify merged-juxt [s c]
  (let [args (get-args c)]
    (merged-juxt (map stepify
                      (sequence-steps (count args) s)
                      args))))


(defmethod stepify :default [s v]
  v)

(defn params-step [s [init-scene [step-fs step-scene]]]
  [init-scene [(stepify s step-fs) step-scene]])

(def EPSILON 0.01)
(defn fractal-with-steps [params details]
  (let [[init-scene step-params] params
        int-d (int details)
        int-fractal (nth (iterate (partial fractal-step step-params) init-scene) int-d)
        fractional-d (- details int-d)]
    (if (<= fractional-d EPSILON)
      int-fractal
      (fractal-step (second (params-step fractional-d params)) int-fractal))))


#+END_SRC

#+NAME: src-fractal-with-steps-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal-with-steps (sierpinski-params 3) 1.75)]

#+END_SRC


#+NAME: src-fractal-sierpinski
#+BEGIN_SRC clojure :exports none
         (defn fractal-step [[step-f step-elts] current-elts]
  (into step-elts (step-f current-elts)))

(defn fractal [[init-elts step-params] details]
  (nth (iterate (partial fractal-step step-params) init-elts) details))

         (defn merged-juxt[fs]
         (comp (partial reduce into [])(apply juxt fs)))
         ;; cf. infra
         (defn merged-juxt[fs]
         (with-meta (comp (partial reduce into []) (apply juxt fs))
         {:is-from merged-juxt
         :args fs}))


(defn sierpinski-params [n]
  (let[step-elt (regular-polygon n)
       make-transform #(make-polylines-transform (comp (partial add %)
                                                       (partial scale (/ 1 (dec n)))))]
  (condp = n
    3 [[]
       [(merged-juxt (for [i [0 1 2]] (make-transform (rotate (+ PI (* i 2 (/ PI 3))) [1. 0.]))))
        [step-elt]]]
    4 [[]
       [(merged-juxt (let [d [-1 0 1]]
                       (for [dx d dy d :when (not= 0 dx dy)]
                         (make-transform (scale (sqrt 2.) [dx dy])))))
        [(map (partial rotate (/ PI 4)) step-elt)]]])))
#+END_SRC

#+NAME: src-fractal-sierpinski-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal (sierpinski-params 3) 6)]
#+END_SRC



#+NAME: src-fractal-tree
#+BEGIN_SRC clojure :exports none
(defn tree-params [angles]
  (let[branch [0 -1]
       ratio (/ (+ 1 (sqrt 5.)) 2.)]
    [[]
     [(merged-juxt (for [a angles]
                     (make-polylines-transform
                                             (comp (partial add branch)
                                                      (partial scale (/ 1 ratio))
                                                      (partial rotate a)))))
      [[[0. 0] branch]]]]))
#+END_SRC

#+NAME: src-fractal-tree-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal (tree-params [(/ PI 6)(/ PI -3)]) 8)]
#+END_SRC

#+NAME: src-fractal-koch
#+BEGIN_SRC clojure :exports none
(def koch-params [[[[-0.5 0][0.5 0]]]
                  [(merged-juxt (for [[v a] [[[(/ -1 3) 0] 0]
                                             [[(/ 1 3) 0] 0]
                                             [(rotate (/ PI -3) [(/ 1 6) 0]) (/ PI 3)]
                                             [(rotate (/ PI 3) [(/ -1 6) 0]) (/ PI -3)]]]
                                        (make-polylines-transform (comp (partial add v)
                                                                   (partial rotate a)
                                                                   (partial scale (/ 1 3))))))
                   []]])
#+END_SRC

#+NAME: src-fractal-koch-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal koch-params 4)]
#+END_SRC

#+NAME: src-fractal-hilbert-transform
#+BEGIN_SRC clojure :exports none
    ;; hilbert is different because there is only one polyline. We do not transform and merge sequences of polylines but transform and merge polylines (sequences of points). Also, the initial polyline is only one point long.
(def hilbert-transform
    (comp (merged-juxt
            [(comp (partial mapv (comp (partial add [-0.5 0.5]) (partial rotate (/ PI 2)))) reverse)
             (partial mapv (partial add [-0.5 -0.5]))
        	 (partial mapv (partial add [0.5 -0.5]))
             (comp (partial mapv (comp (partial add [0.5 0.5]) (partial rotate (/ PI -2)))) reverse)])
          (partial mapv (partial scale 0.5))))
#+END_SRC

#+NAME: src-fractal-hilbert-transform-use
#+BEGIN_SRC clojure :exports none
    [draw-fitted-polylines [400 400] [(nth (iterate hilbert-transform [[0 0]]) 5)]]
#+END_SRC


#+NAME: src-fractal-hilbert
#+BEGIN_SRC clojure :exports none
    (def hilbert-params [[[[0 0]]] [(partial mapv hilbert-transform) []]])
#+END_SRC

#+NAME: src-fractal-hilbert-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal hilbert-params 6)]
#+END_SRC


#+NAME: src-fractal-koch-line-transform
#+BEGIN_SRC clojure :exports none
    (def koch-transform
    (let [s (partial scale (/ 1 3))]
    (comp (merged-juxt
            [(partial mapv (comp (partial add [(/ -1 3) 0]) s))
    (comp rest (partial mapv (comp (partial add (rotate (/ PI 3) [(/ -1 6) 0])) (partial rotate (/ PI -3)) s)))
    (comp rest (partial mapv (comp (partial add (rotate (/ PI -3) [(/ 1 6) 0])) (partial rotate (/ PI 3)) s)))
    (comp rest (partial mapv (comp (partial add [(/ 1 3) 0]) s)))]))))
#+END_SRC

#+NAME: src-fractal-koch-line-transform-use
#+BEGIN_SRC clojure :exports none
    [draw-fitted-polylines [400 400] [(nth (iterate koch-transform [[-0.5 0][0.5 0]]) 2)]]
#+END_SRC

#+NAME: src-fractal-koch-line
#+BEGIN_SRC clojure :exports none
    (def koch-line-params [[[[-0.5 0] [0.5 0]]] [(partial mapv koch-transform) []]])
#+END_SRC

#+NAME: src-fractal-koch-line-use
#+BEGIN_SRC clojure :exports none
[draw-fitted-polylines [400 400] (fractal koch-line-params 6)]
#+END_SRC

#+call: inline-html-header()
#+call: inline-klipse-header()


#+call: inline-hidden-klipse-clojure-s('("init-reagent-examples" "src-dynamic-homoiconicity" "src-svg-polyline" "src-draw-polylines" "src-add" "src-make-polylines-transform"  "src-rotate" "src-scale" "src-draw-fitted-polylines" "src-make-rotate-around" "src-regular-polygon" "src-fractal-sierpinski" "src-fractal-tree" "src-fractal-koch" "src-fractal-hilbert-transform" "src-fractal-hilbert" "src-fractal-koch-line-transform" "src-fractal-koch-line" "src-fractal-with-steps"))


#+call: inline-klipse-reagent-s('("src-gui-fractals" "src-gui-fractals-use"))

#+call: inline-klipse-reagent-s('("src-gui-fractals-with-steps" "src-gui-fractals-with-steps-use"))

#+call: inline-klipse-reagent-s('("src-fractal-sierpinski" "src-fractal-sierpinski-use"))

#+call: inline-klipse-reagent-s('("src-regular-polygon" "src-regular-polygon-use"))

#+call: inline-klipse-reagent-s('("src-fractal-tree" "src-fractal-tree-use"))

#+call: inline-klipse-reagent-s('("src-fractal-koch" "src-fractal-koch-use"))

#+call: inline-klipse-reagent-s('("src-fractal-hilbert-transform" "src-fractal-hilbert-transform-use"))

#+call: inline-klipse-reagent-s('("src-fractal-hilbert" "src-fractal-hilbert-use"))

#+call: inline-klipse-reagent-s('("src-fractal-koch-line-transform" "src-fractal-koch-line-transform-use"))

#+call: inline-klipse-reagent-s('("src-fractal-koch-line" "src-fractal-koch-line-use"))

** Future Works
- Fractal in Fractal : step-elt as a function of step nb to adjust for required precision
- hilbert in sierpinski 4
- golden ratio squares and curve
- golden ratio with sierpinski squares
#+call: text-test()

#+END_EXPORT

#+call: inline-klipse-footer()



* Bezier curves
* polylines interpolations
* Snowflakes
by folding and cutting
* tiles
* patterns
* celtic patterns
* bounces

* physics
* solar system
Euler -> Verlet
* Fractal texts
ISEP
 
ISEPISEP
    S
    E
    P
    I
    S
    E
 ISEPISEP

ISEPISEP
S
E
P
ISEPISEP
S
E
P
ISEPISEP


ISEPISEP
S
E
P
ISEPISEPI
        S
        E
 ISEPISEP

ISEPISEPI
S       S
E       E
PISEPISEP
I
S
E
P


https://github.com/Enderer/sixteensegment/blob/master/src/SixteenSegment.js

* Mazes
* Data viz
http://blog.klipse.tech/data/2017/03/17/data-driven-documents-google-charts.html



?♂♀



#+BEGIN_EXPORT html
<script>
window.klipse_settings = {
  selector: '.klipse',
  selector_reagent: '.reagent'
};
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>


#+END_EXPORT
